# Conventions

All these conventions are meant to provide cues for discussions. If we ever need to break any of these, it does not mean we _can not_ do it, it just means we _should not_. Therefore it should be a cue for the engineer to initiate a wider discussion to see if overriding these guidelines is either the right thing to do, or if there is a better way in handling the issue at hand.

## Process

-   Do not fix things unrelated to your task, instead open up a bug ticket for prioritization.

## HTML

-   Whenever possible break raw HTML blocks into reusable React Components.
-   Do not style HTML tags globally unless for reset purposes.

## CSS

-   Do not put any positioning CSS (e.g. `top`, `left`) inside a component's outermost styles.
-   Do not put any margin CSS (e.g. `margin-top`, `margin-bottom`) inside a component's outermost styles.
-   Only use CSS properties that are absolutely necessary. Do not add superfluous styles.
-   Do not use CSS shorthand properties as it makes it harder to override.
-   Try not to use `top` and `left`, instead use margins or gap.
-   Try to generally give elements only top and left margins for positioning purposes.
-   Make sure to get the color hex values from the design (do not guess / eyeball the color).
-   Always use the semantic colors from `styles/colors.scss`, never the color variables directly.
-   When defining a new font, include the responsiveness in the mixin.
-   Try not to set fixed heights, allow content to define height.
-   Only import `global.scss` into your `styles.module.scss`.
-   Try not to nest CSS selectors unless they are pseudo-selectors (e.g. `:hover`).
-   Always assign a class name to the root element of a component that reflects the component name.
-   Consumer of component controls positioning, spacing, and z-index.
-   Write text in plain English casing and use CSS to style it (e.g. uppercase).
-   Introduce CSS properties in the right breakpoints when they are needed, not sooner.
-   Anything layout related should use CSS grids.
-   Use `px` measuring unit by default.
-   Do not mix different measuring units
-   Never ever use `!important` (instead learn about CSS specificity).

## Javascript

-   Always use the optional chaining operator instead of binary operator.
-   Always reference files via their absolute path (e.g. `components/Logo`) rather than their relative path.
-   Do not use switch statements.
-   Do not spread props into a component, list them out.
-   Put any configurable variables (e.g. paths, URLs) that are not coming from CMS into .env.sample
-   Only introduce functionality you need _now_ (not in the possible future).
-   Use more specific names if we anticipate it being less re-usable (and therefore the logic can be more specific).
-   Use more generic names if we anticipate it being more re-usable (and therefore the logic must be more generic).
-   Avoid possible double-negative logic (e.g. prefer `isRequired` over `notRequired`).

## React

-   Introduce loop construct for components only if more than three items.
-   Pages and layouts do NOT need an associated storybook file.
-   Each component must have an associated storybook file (`stories.js`).
-   Move all service calls to a file called `data.js` inside the page folder
-   Move all constants to a file called `constants.js` inside the component folder.
-   Move all component logic to a file called `index.js` inside the component folder.
-   No component should need more than one HTML tag.
-   Each HTML tag is an opportunity to break it out into its own component.
-   Do not allow overriding CSS of an internal component of a composed component.
-   No component should ever need to have over 100 lines of code.

## Assets

-   Use SVGs for vector graphics.
-   Use JPEGs for photos.
-   Use PNGs for icons needing opacity.
-   If component has an image call it `image` followed by its respective extension.
-   Multiple image files should live in an `images/` sub-folder of component.
-   Do not inline SVGs.

# PR Contents

-   Always include an integration proving introduced functionality is actually needed.

# PR Etiquette

-   Use git labels correctly (see labels in github for more details)
-   Always review and merge PRs in chronological order when possible (FIFO)
-   PRs should be small and single purpose
-   There should be no more than 10 files changed per PR

## PR Size

A problem must be decomposed into a composition of small solutions. Each solution should do one thing, and do that thing correctly, accurately, and predictably. Each such small solution should come with its own PR.

A large PR is difficult to wrap one's mind around, therefore the code reviews will be less effective, and will require more effort from the reviewer. The longer a reviewer is busy reviewing code, the less time the reviewer can work on solving other problems. We do not want to hold up engineers with big PRs.

An engineer should be able to quickly and accurately review a PR within a few minutes.

## PR Sequence

To solve a problem we want to break it down from the outside inward.

### Example

Let's take a page with a form on it.

-   PR #1: Page with an empty form container
-   PR #2: Build out the UI for the form
-   PR #3: Form validation logic
-   PR #4: Connect form to API

This sequence makes every solution isolated and therefore easy to review, troubleshoot, and cherry-pick for whatever reason (roll-back, move to another branch, etc)

# Opinions

-   Favor CSS modules using SCSS rather than styled components.
